#+TITLE: Claude Code Diff Viewing Mechanism - Technical Specification
#+AUTHOR: Ada
#+DATE: May 31, 2025

* Overview

The Claude Code diff viewing mechanism provides a sophisticated integration with VS Code's native diff capabilities through a WebSocket-based MCP (Model Context Protocol) architecture. The system uses event-driven promise racing to handle multiple user interaction paths while maintaining clean resource management.

* Architecture Components

** WebSocket-based MCP Communication
The system uses WebSocket connections with MCP (Model Context Protocol) for bidirectional communication:

- VS Code Extension: Acts as MCP server, hosts WebSocket server on localhost
- Claude Code CLI: Acts as MCP client, connects to extension's WebSocket server
- Protocol: Standard WebSocket with "mcp" subprotocol for structured message exchange
- Transport Layer: JSON-serialized MCP messages over WebSocket connection

** Virtual File System
Claude Code implements two virtual file system providers to manage temporary diff content without creating actual files:

- =_claude_fs_left=: Original file content (left side of diff)
- =_claude_fs_right=: Modified file content (right side of diff)

Each virtual FS maintains an in-memory map of documents with full file system operations (stat, read, write).

** Key Classes

*** WebSocket Transport (=Wr= class)
- Wraps WebSocket connection with MCP-compatible interface
- Handles connection lifecycle (open, close, error events)
- JSON message serialization/deserialization
- Automatic reconnection and error handling

*** Virtual File Provider (=Wt= class)
- Manages temporary files in memory
- Provides VS Code FileSystemProvider interface
- Handles file operations without disk I/O
- Implements watch, stat, readFile, writeFile methods

*** Virtual Document (=Gn= class)
- Stores URI, contents, timestamps
- Emulates file properties (size, type, ctime/mtime)
- Supports text encoding/decoding operations

* Diff Creation Workflow

** 1. CLI Tool Invocation
The CLI calls the =openDiff= MCP tool via WebSocket with this structure:
#+BEGIN_SRC javascript
await yL("openDiff", {
  old_file_path: "/path/to/file",     // Path to original file
  new_file_path: "/path/to/file",     // Path to modified file (usually same)
  new_file_contents: "modified text", // Content to show as modified version
  tab_name: "filename.ext"            // Display name for diff tab
}, mcpClient, isNonInteractiveSession)
#+END_SRC

** 2. MCP Message Transport
The CLI tool call is serialized as an MCP message over WebSocket:
#+BEGIN_SRC javascript
{
  "jsonrpc": "2.0",
  "id": requestId,
  "method": "tools/call",
  "params": {
    "name": "openDiff",
    "arguments": { old_file_path, new_file_path, new_file_contents, tab_name }
  }
}
#+END_SRC

** 3. VS Code Extension Processing
The extension receives the MCP message and executes the =To= function (main diff implementation):

*** File URI Preparation
#+BEGIN_SRC javascript
// Left side logic:
let leftUri = vscode.Uri.file(old_file_path);
try {
  if ((await vscode.workspace.openTextDocument(leftUri)).isDirty) {
    let savedContent = fs.readFileSync(old_file_path, 'utf8');
    leftUri = leftFileProvider.createFile(old_file_path, savedContent).uri;
  }
} catch {
  leftUri = leftFileProvider.createFile(old_file_path, '').uri; // File doesn't exist
}

// Right side logic - always create virtual file
let rightUri = rightFileProvider.createFile(new_file_path, new_file_contents).uri;
#+END_SRC

*** Tab Management
- Searches for existing diff tabs with same modified URI
- Closes duplicate tabs with 200ms delay for UI stability
- Ensures clean diff viewing experience

*** VS Code Diff Execution
#+BEGIN_SRC javascript
await vscode.commands.executeCommand('vscode.diff', leftUri, rightUri, tab_name, {preview: false});
#+END_SRC

** 4. Promise Racing Setup
The extension sets up multiple concurrent event listeners using =Promise.race()=:

#+BEGIN_SRC javascript
async function To(...) {
  let eventListeners = []; // Track for cleanup
  
  // Promise 1: Accept/Reject Commands
  let acceptRejectPromise = new Promise((resolve) => {
    eventListeners.push(
      tabChangeListener((event) => {
        if (event.activeTab && isDiffTab(event.activeTab)) {
          resolve(event); // {accepted: true/false, activeTab}
        }
      })
    );
  });

  // Promise 2: Tab Closure Detection  
  let tabClosePromise = pollForTabClosure(() => 
    !getActiveTabs().some(tab => tab.isDiff && tab.label === tab_name)
  );

  // Promise 3: File Save Detection (when auto-save off)
  let fileSavePromise = new Promise((resolve) => {
    eventListeners.push(
      vscode.workspace.onWillSaveTextDocument((event) => {
        if (event.document.uri.toString() === rightUri.toString()) {
          resolve(event.document.getText());
        }
      })
    );
  });

  // Race setup - first promise to resolve wins
  let promises = [tabClosePromise, acceptRejectPromise];
  if (vscode.workspace.getConfiguration('files').get('autoSave') === 'off') {
    promises.push(fileSavePromise);
  }
  
  let result = await Promise.race(promises);
  
  // Cleanup all event listeners
  eventListeners.forEach(disposable => disposable.dispose());
  
  return result; // Becomes MCP tool response
}
#+END_SRC

* Event-Driven Resolution

** Accept/Reject Commands
Two commands registered in VS Code extension:
- =claude-code.acceptProposedDiff=: Signals acceptance
- =claude-code.rejectProposedDiff=: Signals rejection

#+BEGIN_SRC javascript
vscode.commands.registerCommand('claude-code.acceptProposedDiff', async () => {
  let activeTab = vscode.window.tabGroups.activeTabGroup.activeTab;
  eventEmitter.fire({ accepted: true, activeTab });
  returnFocusToTerminal(); // De() function
});

vscode.commands.registerCommand('claude-code.rejectProposedDiff', async () => {
  let activeTab = vscode.window.tabGroups.activeTabGroup.activeTab;
  eventEmitter.fire({ accepted: false, activeTab });
  returnFocusToTerminal(); // De() function
});
#+END_SRC

** Resolution Event Types

*** 1. User Accept/Reject (Command Execution)
#+BEGIN_SRC javascript
// Accept clicked
{
  content: [
    { type: 'text', text: 'FILE_SAVED' },
    { type: 'text', text: actualFileContent }
  ]
}

// Reject clicked  
{
  content: [
    { type: 'text', text: 'DIFF_REJECTED' },
    { type: 'text', text: tab_name }
  ]
}
#+END_SRC

*** 2. Tab Closure (Manual Close)
#+BEGIN_SRC javascript
// Tab manually closed
{
  content: [
    { type: 'text', text: 'TAB_CLOSED' },
    { type: 'text', text: tab_name }
  ]
}
#+END_SRC

*** 3. File Save (Auto-Save Disabled)
#+BEGIN_SRC javascript
// File saved via Ctrl+S
{
  content: [
    { type: 'text', text: 'FILE_SAVED' },
    { type: 'text', text: savedFileContent }
  ]
}
#+END_SRC

** Document Change Tracking
Maintains content history for undo/redo edge case handling:
#+BEGIN_SRC javascript
vscode.workspace.onDidChangeTextDocument((event) => {
  if (event.document.uri.toString() === rightUri.toString()) {
    previousContent = currentContent;
    currentContent = event.document.getText();
    
    // Handle bulk changes (>3 changes) that aren't undo/redo
    if (event.contentChanges.length > 3 &&
        event.reason !== vscode.TextDocumentChangeReason.Undo &&
        event.reason !== vscode.TextDocumentChangeReason.Redo) {
      contentBackup = { time: Date.now(), contents: previousContent };
    }
  }
});
#+END_SRC

* WebSocket Response Protocol

** MCP Tool Response Structure
All resolution paths return the same standardized MCP response format:
#+BEGIN_SRC javascript
{
  "jsonrpc": "2.0",
  "id": requestId,
  "result": {
    "content": [
      { "type": "text", "text": STATUS },      // FILE_SAVED, DIFF_REJECTED, or TAB_CLOSED
      { "type": "text", "text": CONTENT }      // File content (for saves) or tab name (for rejections)
    ]
  }
}
#+END_SRC

** WebSocket Message Flow
1. **Extension Promise Resolution**: When any racing promise resolves, the result becomes the MCP tool response
2. **JSON Serialization**: Response is serialized as JSON-RPC message
3. **WebSocket Send**: Message sent over WebSocket connection to CLI
4. **CLI Promise Resolution**: CLI's awaited =callTool()= promise resolves with the response

** CLI Response Processing
The CLI processes responses using type checking functions:
#+BEGIN_SRC javascript
// CLI response validators
function isFileSaved(response) {
  return response.type === "result" && 
         Array.isArray(response.data) && 
         response.data[0]?.type === "text" && 
         response.data[0].text === "FILE_SAVED";
}

function isDiffRejected(response) {
  return response.type === "result" && 
         Array.isArray(response.data) && 
         response.data[0]?.type === "text" && 
         response.data[0].text === "DIFF_REJECTED";
}

function isTabClosed(response) {
  return response.type === "result" && 
         Array.isArray(response.data) && 
         response.data[0]?.type === "text" && 
         response.data[0].text === "TAB_CLOSED";
}

// Final resolution logic
if (isFileSaved(response)) {
  return { oldContent: original, newContent: response.data[1].text };      // User accepted
} else if (isTabClosed(response)) {
  return { oldContent: original, newContent: modifiedContent };            // Tab closed
} else if (isDiffRejected(response)) {
  return { oldContent: original, newContent: original };                   // User rejected
} else {
  throw new Error("Not accepted");                                         // Unexpected response
}
#+END_SRC

* Resource Management and Cleanup

** Event Listener Disposal
All VS Code event listeners are tracked and automatically cleaned up:
#+BEGIN_SRC javascript
async function To(...) {
  let eventListeners = []; // Disposal tracking array
  try {
    // Register event listeners
    eventListeners.push(
      vscode.workspace.onWillSaveTextDocument(...),
      vscode.workspace.onDidChangeTextDocument(...),
      tabChangeListener(...),
      // ... other listeners
    );
    
    return await Promise.race(promises);
  } finally {
    // Guaranteed cleanup
    for (let disposable of eventListeners) {
      disposable.dispose();
    }
  }
}
#+END_SRC

** Virtual File System Lifecycle
- Virtual files persist in memory until FileSystemProvider disposal
- No temporary files created on disk
- Automatic garbage collection when providers are disposed

** Tab Management
- Automatic cleanup of duplicate diff tabs before opening new ones
- 200ms delay prevents UI flickering during tab transitions
- Preserves user's active tab selection

** WebSocket Connection Management
- Connection lifecycle handled by transport layer
- Automatic reconnection and error handling
- Graceful degradation on connection loss

* Key Design Decisions

** WebSocket-based MCP Architecture
1. **Bidirectional Communication**: Enables real-time event streaming from editor to CLI
2. **Structured Protocol**: MCP provides standardized message format and error handling
3. **Async/Await Integration**: Natural Promise-based programming model
4. **Multiple Client Support**: Single VS Code instance can serve multiple CLI sessions

** Virtual File System Approach
1. **No Workspace Pollution**: Temporary files exist only in memory
2. **Clean Resource Management**: Automatic disposal prevents memory leaks
3. **Cross-Workspace Support**: Handles files outside current workspace
4. **Non-existent File Support**: Can diff against files that don't exist yet

** Promise Racing Pattern
1. **Concurrent Event Handling**: Multiple user interaction paths handled simultaneously
2. **First Action Wins**: Natural resolution semantics without complex state machines
3. **Clean Async Programming**: Elegant alternative to callback-based event handling
4. **Automatic Timeout Protection**: Racing prevents indefinite waiting

** Focus Management Strategy
1. **CLI-Centric Workflow**: Returns focus to terminal after diff operations
2. **User Experience**: Maintains CLI-driven interaction model
3. **Context Preservation**: Prevents unintended focus trapping in editor

* Technical Implementation Details

** WebSocket Server Initialization
#+BEGIN_SRC javascript
// VS Code Extension startup
function startMCPServer(context) {
  let httpServer = http.createServer();
  let wsServer = new WebSocketServer({ server: httpServer });
  let mcpServer = new MCPServer({
    name: getExtensionName(),
    version: context.extension.packageJSON.version
  });
  
  wsServer.on('connection', (websocket, request) => {
    let transport = new WebSocketTransport(websocket);
    mcpServer.connect(transport);
  });
  
  httpServer.listen(port, '127.0.0.1', () => {
    // Set environment variables for CLI discovery
    setEnvironmentVariable('CLAUDE_CODE_SSE_PORT', String(port));
    setEnvironmentVariable('ENABLE_IDE_INTEGRATION', 'true');
  });
}
#+END_SRC

** CLI WebSocket Client Connection
#+BEGIN_SRC javascript
// CLI connects to VS Code extension
if (clientConfig.type === "ws-ide") {
  let websocket = new WebSocket(clientConfig.url, ["mcp"]);
  let transport = new WebSocketTransport(websocket);
  let mcpClient = new MCPClient(transport);
  await mcpClient.connect();
}
#+END_SRC

** Error Handling and Timeouts
#+BEGIN_SRC javascript
// CLI tool execution with timeout
async function callTool(toolName, args, client) {
  try {
    let response = await client.callTool(
      { name: toolName, arguments: args },
      requestOptions,
      { signal: abortController.signal, timeout: TOOL_TIMEOUT }
    );
    return processToolResponse(response);
  } catch (error) {
    if (error.name === 'TimeoutError') {
      throw new Error(`Tool execution timed out after ${TOOL_TIMEOUT}ms`);
    }
    throw error;
  }
}
#+END_SRC

This specification documents the complete technical implementation of Claude Code's diff viewing mechanism, focusing on the WebSocket-based MCP architecture and event-driven promise racing system that enables seamless communication between the CLI and VS Code extension.