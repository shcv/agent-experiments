#+TITLE: Claude Code Hooks - Complete Reference Guide
#+DATE: 2025-07-24
#+UPDATED: Based on official Claude Code documentation at https://docs.anthropic.com/en/docs/claude-code/hooks

* Overview

Claude Code hooks allow you to execute custom commands at specific points during Claude's operation. Hooks can inspect, modify, approve, or block operations, providing powerful control over Claude Code's behavior.

** Key Features
- Execute shell commands automatically based on Claude's actions
- Control flow with exit codes and JSON responses
- Filter by tool names using exact or regex patterns
- 60-second default timeout for hook execution
- Runs in the current directory with access to CLAUDE_PROJECT_DIR environment variable
- Hooks run in parallel when multiple match the same event

* Available Hook Events

Claude Code supports 7 hook events (defined in =$IA= array at line 28680):

| Event | When It Fires | Primary Use Case |
|-------+---------------+------------------|
| =PreToolUse= | Before any tool execution | Validate/block dangerous operations |
| =PostToolUse= | After tool completion | Log actions, cleanup, notifications |
| =Notification= | When notifications are sent | Custom notification handling |
| =UserPromptSubmit= | When user submits a prompt | Pre-process user input |
| =Stop= | Before Claude concludes response | Final checks, cleanup |
| =SubagentStop= | Before subagent (Task) concludes | Subagent-specific cleanup |
| =PreCompact= | Before conversation compaction | Add custom compact instructions |

The complete list is: =["PreToolUse", "PostToolUse", "Notification", "UserPromptSubmit", "Stop", "SubagentStop", "PreCompact"]=

* Hook Configuration

** Configuration Files
Hooks can be configured in three levels of settings files:
- User settings: =~/.claude/settings.json=
- Project settings: =<project>/.claude/settings.json=
- Local settings: =<project>/.claude/settings.local.json=

** Configuration Structure

Hooks are configured using schemas defined in the code:

*** Hook Type Schema (=y4Q= at line 28917)
#+begin_src javascript
{
  type: "command",  // Currently only "command" is supported
  command: string,  // Shell command to execute
  timeout: number   // Optional, positive number in seconds
}
#+end_src

*** Matcher Configuration Schema (=k4Q= at line 28922)
#+begin_src javascript
{
  matcher: string,  // Optional string pattern to match
  hooks: [...]      // Array of hook definitions
}
#+end_src

*** Full Configuration Format
#+begin_src json
{
  "hooks": {
    "EventName": [
      {
        "matcher": "optional pattern",
        "hooks": [
          {
            "type": "command",
            "command": "your-command-here",
            "timeout": 30  // optional, in seconds
          }
        ]
      }
    ]
  }
}
#+end_src

** Key Components
- =EventName=: One of the 7 available events
- =matcher=: Optional string pattern for filtering (regex supported, use =*= to match all)
- =type=: Currently only "command" is supported
- =command=: Shell command to execute
- =timeout=: Optional timeout in seconds (default: 60, max: 600)

* Data Passed to Hooks

Hooks receive JSON data via stdin. The data structure includes common fields plus event-specific data:

** Common Fields (All Events)

Based on analysis of the core implementation, all hook payloads include these base fields:

#+begin_src json
{
  "hook_event_name": "EventName",     // The specific event type
  "session_id": "unique-session-id",   // From cB() function
  "transcript_path": "/path/to/transcript", // From nM1() function  
  "cwd": "/current/working/directory"  // From a0() function
}
#+end_src

The =ie()= function at line 28508 generates these common fields for all hook payloads.

** PreToolUse

Generated by =NqB()= function (line 28910):

#+begin_src json
{
  "hook_event_name": "PreToolUse",
  "tool_name": "Write",              // The tool being invoked
  "tool_input": {                   // Complete tool input object
    "file_path": "/path/to/file.txt",
    "content": "file contents"
  },
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "transcript_path": "/path/to/transcript",
  "cwd": "/current/working/directory"
}
#+end_src

** PostToolUse

Generated by =LqB()= function (line 28915):

#+begin_src json
{
  "hook_event_name": "PostToolUse",
  "tool_name": "Bash",              // The tool that was executed
  "tool_input": {                   // Original tool input
    "command": "ls -la",
    "timeout": 120000
  },
  "tool_response": {                // Complete tool response/output
    "output": "command output",
    "exit_code": 0,
    "error": null
  },
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "transcript_path": "/path/to/transcript",
  "cwd": "/current/working/directory"
}
#+end_src

** Notification

Generated by =MqB()= function (line 28929):

#+begin_src json
{
  "hook_event_name": "Notification",
  "message": "Claude is waiting for your input",  // Notification message
  "title": "Claude Code",                         // Notification title
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "transcript_path": "/path/to/transcript",
  "cwd": "/current/working/directory"
}
#+end_src

** UserPromptSubmit  

Generated by =OqB()= function (line 28937):

#+begin_src json
{
  "hook_event_name": "UserPromptSubmit",
  "prompt": "Help me refactor this code",  // The user's input prompt
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "transcript_path": "/path/to/transcript",
  "cwd": "/current/working/directory"
}
#+end_src

** Stop / SubagentStop

Generated by =RqB()= function (line 28933):

#+begin_src json
{
  "hook_event_name": "Stop",        // or "SubagentStop" for subagents
  "stop_hook_active": true,         // Whether stop hooks are active
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "transcript_path": "/path/to/transcript",
  "cwd": "/current/working/directory"
}
#+end_src

** PreCompact

Generated by =TqB()= function (line 28941):

#+begin_src json
{
  "hook_event_name": "PreCompact",
  "trigger": "auto",                // "auto" or "manual" compaction
  "custom_instructions": null,       // Any existing custom instructions
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "transcript_path": "/path/to/transcript",
  "cwd": "/current/working/directory"
}
#+end_src

* Hook Control Mechanisms

** Exit Codes

Hooks communicate through exit codes:

| Exit Code | Meaning | Effect |
|-----------+---------+--------|
| 0 | Success | Continue normally |
| 1 | Non-blocking error | Show stderr to user, continue |
| 2 | Blocking error | Block operation (PreToolUse only) |
| Other | Error | Show stderr to user, continue |

** JSON Response Format

Hooks can return structured JSON for fine-grained control:

*** Standard Response Schema

Hooks can return JSON responses that are validated using the =l48= schema (line 28511):

#+begin_src json
{
  "continue": boolean,          // Whether to continue execution (optional)
  "suppressOutput": boolean,    // Suppress hook output display (optional)
  "stopReason": "string",      // Reason for stopping if continue=false (optional)
  "decision": "approve|block",  // Decision for the operation (optional)
  "reason": "string",          // Human-readable reason (optional)
  "hookSpecificOutput": {      // Event-specific outputs (optional)
    // See event-specific schemas below
  }
}
#+end_src

**** Event-Specific Output Schemas

***** PreToolUse
#+begin_src json
{
  "hookEventName": "PreToolUse",
  "permissionDecision": "allow|deny|ask",  // Tool permission override (optional)
  "permissionDecisionReason": "string"     // Reason for permission decision (optional)
}
#+end_src

***** UserPromptSubmit  
#+begin_src json
{
  "hookEventName": "UserPromptSubmit",
  "additionalContext": "string"  // Additional context to include (optional)
}
#+end_src

*** PreCompact Hook Processing

The =TqB()= function handles PreCompact hooks specially:

1. Successful hooks with output have their stdout collected
2. All outputs are joined with double newlines
3. Result object contains:
   - =newCustomInstructions=: Combined output from all successful hooks
   - =userDisplayMessage=: Status messages for each hook

Example processing (lines 28945-28965):
#+begin_src javascript
// Collect successful outputs
let outputs = results
  .filter(r => r.succeeded && r.output.trim().length > 0)
  .map(r => r.output.trim());

// Join with double newlines
return {
  newCustomInstructions: outputs.length > 0 ? outputs.join("\n\n") : undefined,
  userDisplayMessage: statusMessages.join("\n")
};
#+end_src

*** Hook Response Processing

The =p48()= function (line 28528) parses hook output:
1. If output doesn't start with "{", it's treated as plain text
2. JSON is parsed and validated against the =l48= schema
3. Validation errors are logged but don't stop execution

The =i48()= function (line 28548) converts validated JSON to internal format:
- =continue: false= sets =preventContinuation=true=
- =decision= maps to =permissionBehavior= ("approve"→"allow", "block"→"deny")
- =permissionDecision= also maps to =permissionBehavior=
- =hookSpecificOutput= is processed based on event type

** Control Flow Examples

*** Blocking a Tool
PreToolUse hook returning exit code 2:
#+begin_src bash
#!/bin/bash
if [[ "$1" == *"rm -rf"* ]]; then
  echo "Dangerous command blocked" >&2
  exit 2
fi
exit 0
#+end_src

*** Approving with Reason
#+begin_src bash
#!/bin/bash
echo '{"decision": "approve", "reason": "File write to safe directory"}'
exit 0
#+end_src

*** Stopping Execution
#+begin_src bash
#!/bin/bash
echo '{"continue": false, "stopReason": "Daily limit reached"}'
exit 0
#+end_src

* Matcher Patterns and Hook Selection

** Hook Selection Logic

The =EqB()= function (line 28672) implements hook selection:

1. Retrieves all hook configurations for the event type
2. Determines what to match against based on event:
   - =PreToolUse=/=PostToolUse=: Matches against =tool_name=
   - Other events: No specific matching field
3. If no query value, returns all hooks
4. Otherwise filters hooks where matcher matches the query
5. Deduplicates hooks by command

** Pattern Matching Implementation

The =n48()= function (line 28665) handles pattern matching:
#+begin_src javascript
function n48(value, pattern) {
  try {
    return new RegExp(pattern).test(value);
  } catch {
    // Invalid regex, treat as literal string match
    return false;
  }
}
#+end_src

** Pattern Matching Rules
- Empty/missing matcher: Hook runs for all events of that type
- Valid regex: Tested against the value using RegExp
- Invalid regex: Logged and treated as no match
- Supports full JavaScript regex syntax

** Examples
#+begin_src json
{
  "PreToolUse": [
    {
      "matcher": "Write|Edit",  // Matches Write OR Edit tools
      "hooks": [...]
    },
    {
      "matcher": "Bash.*",      // Matches any Bash variant
      "hooks": [...]
    },
    {
      // No matcher - runs for ALL tools
      "hooks": [...]
    }
  ]
}
#+end_src

* Practical Examples

** Example 1: Audit Logging
Log all file modifications:
#+begin_src json
{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Write|Edit|MultiEdit",
        "hooks": [{
          "type": "command",
          "command": "echo \"$(date): $TOOL_NAME modified files\" >> ~/claude-audit.log"
        }]
      }
    ]
  }
}
#+end_src

** Example 2: Security Check
Block dangerous bash commands:
#+begin_src python
#!/usr/bin/env python3
# save as check-bash.py
import json
import sys

data = json.loads(sys.stdin.read())
if data['tool_name'] == 'Bash':
    cmd = data['tool_input'].get('command', '')
    dangerous = ['rm -rf /', 'sudo', 'chmod 777']
    
    for danger in dangerous:
        if danger in cmd:
            # Return structured response
            response = {
                "decision": "block",
                "reason": f"Dangerous command detected: {danger}",
                "continue": False
            }
            print(json.dumps(response))
            sys.exit(2)  # Exit code 2 blocks execution

# Approve safe commands
print(json.dumps({"decision": "approve", "reason": "Command is safe"}))
sys.exit(0)
#+end_src

Hook configuration:
#+begin_src json
{
  "hooks": {
    "PreToolUse": [{
      "matcher": "Bash",
      "hooks": [{
        "type": "command",
        "command": "python3 ~/scripts/check-bash.py"
      }]
    }]
  }
}
#+end_src

** Example 3: Custom Notifications
Replace default notifications:
#+begin_src json
{
  "hooks": {
    "Notification": [{
      "hooks": [{
        "type": "command",
        "command": "notify-send \"$(<&0 jq -r .title)\" \"$(<&0 jq -r .message)\""
      }]
    }]
  }
}
#+end_src

** Example 4: Pre-Compact Instructions
Add context before compaction:
#+begin_src bash
#!/bin/bash
# Output becomes custom compact instructions
echo "Remember: User prefers TypeScript with strict mode"
echo "Project uses React 18 with hooks"
exit 0
#+end_src

* Hook Execution Order and Result Combination

** Execution Flow

1. The =Bx1()= function (line 28730) orchestrates hook execution
2. Matching hooks are found via =EqB()= based on event and matcher
3. All matching hooks execute in parallel via =Promise.all()=
4. Results are collected and processed sequentially

** Result Combination Algorithm

When multiple hooks run for the same event, their results are combined as follows:

*** Permission Behavior Priority (PreToolUse)
Permission decisions follow a strict priority order:
1. "deny" - Highest priority, any hook can block
2. "ask" - Medium priority, requires user confirmation unless denied
3. "allow" - Lowest priority, only if no deny/ask
4. "passthrough" - No opinion, ignored

Code at lines 28842-28855:
#+begin_src javascript
switch (N.permissionBehavior) {
  case "deny":
    H = "deny";  // Always takes precedence
    break;
  case "ask":
    if (H !== "deny") H = "ask";  // Unless already denied
    break;
  case "allow":
    if (!H) H = "allow";  // Only if no other decision
    break;
}
#+end_src

*** Blocking Errors
- All blocking errors (exit code 2) are collected in an array
- Displayed to user via =HqB()= function for PreToolUse
- Displayed via =zqB()= function for PostToolUse

*** Stop Execution
- Any hook returning =continue: false= stops further execution
- Last =stopReason= is used if multiple hooks stop
- Sets =preventContinuation=true= in the result

*** Additional Contexts (UserPromptSubmit)
- All =additionalContext= values are collected in an array
- All contexts are passed to Claude as additional information

*** Success Tracking
The system tracks outcomes:
- =success=: Exit code 0 with valid response
- =blocking=: Exit code 2 (blocks operation)
- =non_blocking_error=: Other non-zero exit codes
- =cancelled=: Hook execution was aborted

** Parallel Execution Details

- All hooks for a matcher run simultaneously via =Promise.all()= (line 28826)
- Each hook has independent timeout (default 60s, configurable)
- Abort signals are properly propagated to all hooks
- Results are processed after all complete or timeout

** Checking Hook Configuration
Use =/hooks= command in Claude Code to:
- View current hook configuration
- See which hooks are active
- Debug hook execution issues

* Security Considerations

** Risks
- Hooks run with user privileges
- Can access/modify any user-accessible files
- =sudo= in hooks is dangerous (and warned against)
- Malicious hooks could exfiltrate data

** Best Practices
1. Keep hook scripts in secure locations
2. Use absolute paths in commands
3. Validate all input data
4. Avoid using sudo
5. Log hook executions for audit
6. Test hooks thoroughly before deployment
7. Quote shell variables properly
8. Be cautious with file system access
9. Remember hooks run automatically without user confirmation
10. Use structured JSON responses for clear communication
11. Handle errors gracefully with informative messages
12. Consider performance impact of hook execution

* Limitations and Technical Details

1. **Command Type Only**: Only "command" type validated in =y4Q= schema (line 28918)
2. **No State Between Hooks**: Each execution is independent, use external storage
3. **Timeout Handling**: 
   - Default: 60 seconds (=xx= constant, line 28507)
   - Configurable per hook via timeout field
   - Max appears to be 600 seconds based on documentation
4. **Error Visibility**: 
   - Exit code 2: stderr shown to model (blocking)
   - Other codes: stderr shown to user only
5. **JSON Parsing**: 
   - Invalid JSON logged but treated as plain text
   - Validation errors don't stop execution
6. **Performance**: 
   - Hooks tracked via telemetry (=K1()= calls)
   - Parallel execution for same matcher
7. **Input Size**: Hook input JSON stringified (could fail for huge inputs)
8. **Output Processing**:
   - First 200 chars of stdout logged in debug
   - Full stdout parsed for JSON response
9. **Message Display**:
   - Progress messages shown during execution
   - "Running [HookName]..." displayed once
10. **Abort Handling**: Proper signal propagation with cleanup

* Environment Variables

Hooks inherit Claude Code's environment with additions:
- Standard shell environment via =process.env=
- =CLAUDE_PROJECT_DIR=: Set to =P9()= result (project directory)
- Shell prefix support: If =CLAUDE_CODE_SHELL_PREFIX= is set, commands are wrapped
- Working directory: Set to =a0()= (current working directory)
- Hooks receive input via stdin as JSON string

** Hook Execution Environment (from KqB function, line 28615)
#+begin_src javascript
// Actual command execution
spawn(command, [], {
  env: { ...process.env, CLAUDE_PROJECT_DIR: projectDir },
  cwd: currentWorkingDir(),
  shell: true,
  signal: abortSignal
})
#+end_src

* Debugging Hooks

** Debug Mode
Run Claude Code with =--debug= flag for detailed hook execution logs:
#+begin_src bash
claude --debug
#+end_src

Debug output includes:
- Hook trigger events
- Input data passed to hooks
- Execution timing
- Output and exit codes
- Error messages

** Testing Hooks
#+begin_src bash
# Test your hook with sample data
echo '{"hook_event_name": "PreToolUse", "tool_name": "Write", "tool_input": {"file_path": "test.txt"}}' | ./my-hook.sh

# Test with full schema
cat <<EOF | ./my-hook.sh
{
  "hook_event_name": "PreToolUse",
  "tool_name": "Write",
  "tool_input": {"file_path": "test.txt", "content": "test"},
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "timestamp": "2024-01-15T10:00:00Z",
  "project_dir": "$(pwd)"
}
EOF
#+end_src

** Debug Output
- Use stderr for debug messages (shown on error)
- Log to files for persistent debugging
- Return descriptive error messages
- Check hook execution with =/hooks= command

** Common Issues
1. **Permission denied**: Make scripts executable (=chmod +x=)
2. **Command not found**: Use absolute paths
3. **JSON parse error**: Validate JSON output with =jq=
4. **Timeout**: Increase timeout or optimize script (max 600s)
5. **Configuration not loading**: Check JSON syntax
6. **Hook not triggering**: Verify matcher pattern
7. **Parallel execution conflicts**: Use file locking for shared resources

* Advanced Patterns

** Stateful Hooks
Use external storage for state:
#+begin_src python
import json
import sqlite3

# Track tool usage in database
conn = sqlite3.connect('~/claude-usage.db')
# ... implement tracking logic
#+end_src

** Conditional Approval
#+begin_src bash
#!/bin/bash
# Approve based on time of day
hour=$(date +%H)
if [ $hour -ge 9 ] && [ $hour -le 17 ]; then
  echo '{"decision": "approve", "reason": "Within work hours"}'
else
  echo '{"decision": "block", "reason": "Outside work hours"}'
fi
#+end_src

** Chain Multiple Checks
#+begin_src json
{
  "PreToolUse": [
    {"matcher": "Write", "hooks": [{"command": "check-permissions.sh"}]},
    {"matcher": "Write", "hooks": [{"command": "scan-content.py"}]},
    {"matcher": "Write", "hooks": [{"command": "log-write.sh"}]}
  ]
}
#+end_src

** Input Modification
Modify tool inputs before execution:
#+begin_src python
#!/usr/bin/env python3
import json
import sys

data = json.loads(sys.stdin.read())
if data['tool_name'] == 'Write':
    # Add header to all written files
    content = data['tool_input'].get('content', '')
    header = f"# Generated by Claude Code\n# Session: {data['session_id']}\n\n"
    
    response = {
        "decision": "approve",
        "reason": "Added header",
        "modifiedInput": {
            **data['tool_input'],
            "content": header + content
        }
    }
    print(json.dumps(response))
    
sys.exit(0)
#+end_src

* Hook Command Reference

** Claude Code Commands
- =/hooks=: Display current hook configuration and status
- =claude --debug=: Run with detailed hook execution logging

* Integration Examples

** Git Pre-Commit Integration
#+begin_src json
{
  "hooks": {
    "PreToolUse": [{
      "matcher": "Bash",
      "hooks": [{
        "type": "command",
        "command": "[ \"$(echo $1 | jq -r '.tool_input.command')\" = \"git commit\"* ] && git diff --cached --check"
      }]
    }]
  }
}
#+end_src

** Slack Notifications
#+begin_src bash
#!/bin/bash
# notify-slack.sh
data=$(cat)
event=$(echo "$data" | jq -r '.hook_event_name')
tool=$(echo "$data" | jq -r '.tool_name // "N/A"')

curl -X POST https://hooks.slack.com/services/YOUR/WEBHOOK/URL \
  -H 'Content-Type: application/json' \
  -d "{\"text\": \"Claude Code: $event - Tool: $tool\"}"
#+end_src

* Future Considerations

While not currently available, potential future enhancements might include:
- Additional hook types (HTTP, native plugins)
- More hook events (model changes, auth events)
- Async/background hooks
- Hook composition and chaining
- Built-in hook templates
- WebAssembly support for sandboxed execution

For now, the command-based system provides significant flexibility for most use cases.

* Technical Implementation Summary

** Core Architecture

Claude Code's hook system is implemented through several key components:

*** Data Flow
1. *Event Generation*: Hook events are triggered at specific points in Claude's execution
2. *Payload Construction*: =ie()= function adds common fields (session_id, transcript_path, cwd)
3. *Hook Selection*: =EqB()= finds matching hooks based on event type and matcher
4. *Parallel Execution*: =Bx1()= orchestrates parallel execution via Promise.all()
5. *Result Processing*: =p48()= parses output, =i48()= converts to internal format
6. *Result Combination*: Multiple hook results are merged with specific priority rules

*** Key Functions
- =ie()= (line 28508): Generates base payload fields
- =EqB()= (line 28672): Selects hooks based on event and matcher
- =Bx1()= (line 28730): Main hook execution orchestrator
- =KqB()= (line 28615): Executes individual hook commands
- =p48()= (line 28528): Parses hook output (JSON or plain text)
- =i48()= (line 28548): Converts parsed JSON to internal format
- =n48()= (line 28665): Pattern matching for hook selection

*** Result Combination Rules
1. *Permission Behavior*: deny > ask > allow > passthrough
2. *Blocking Errors*: All collected and displayed
3. *Stop Execution*: Any hook can stop with continue:false
4. *Additional Contexts*: All collected (UserPromptSubmit)
5. *Custom Instructions*: All concatenated (PreCompact)

*** Performance Considerations
- Hooks execute with configurable timeouts (default 60s)
- Parallel execution for same event/matcher
- Telemetry tracking via K1() calls
- Abort signal propagation with proper cleanup

** Summary

Claude Code hooks provide powerful automation and control capabilities:
- 7 events covering the full lifecycle of Claude's operations
- Flexible regex-based matching for targeted hook execution
- Structured JSON input/output for precise control
- Sophisticated result combination for multiple hooks
- Exit codes and JSON responses for flow control
- Parallel execution with proper timeout and abort handling
- Comprehensive telemetry and debug logging

The implementation shows careful attention to error handling, performance, and extensibility while maintaining backward compatibility with simple exit-code based hooks.