* TodoMVC Implementation Specification

** Architecture and Design Patterns

*** Separation of Concerns
- Clear separation between data model, business logic, and presentation
- No direct DOM manipulation in business logic
- No business rules embedded in view templates
- State management isolated from UI components

*** Data Model
- Todo item structure with required fields:
  - Unique identifier (id)
  - Text content
  - Completion status (boolean)
  - Creation timestamp (optional but recommended)
- Immutable data updates (no direct mutation)
- Single source of truth for application state

*** State Management
- Centralized state container or clear state ownership
- Predictable state updates through defined actions/methods
- State changes trigger UI updates automatically
- No duplicate state across components

** Code Organization

*** Module Structure
- Logical grouping of related functionality
- Clear file/folder organization (e.g., models/, views/, controllers/)
- Consistent naming conventions
- No circular dependencies

*** Component Design
- Single responsibility per component/module
- Reusable components where appropriate
- Clear interfaces between components
- Minimal coupling between modules

** Implementation Quality

*** Error Handling
- Graceful handling of edge cases:
  - Empty todo text
  - Extremely long text input
  - Invalid state transitions
- User-friendly error messages
- No console errors during normal operation

*** Performance
- Efficient rendering (no unnecessary re-renders)
- Smooth interactions without lag
- Reasonable memory usage
- Fast initial load time
- Debounced/throttled operations where appropriate

*** Accessibility
- Semantic HTML elements
- Proper ARIA labels where needed
- Keyboard navigation support:
  - Tab through interactive elements
  - Enter to submit forms
  - Escape to cancel operations
- Screen reader compatibility

** Data Persistence

*** Storage Implementation
- LocalStorage or similar browser storage
- Robust serialization/deserialization
- Handle storage quota errors
- Migrate data schema if needed
- Clear error recovery for corrupted data

*** Sync Behavior
- Save on every state change or with minimal delay
- Load persisted data on application start
- Handle concurrent tab scenarios gracefully

** User Experience

*** Input Handling
- Trim whitespace from todo text
- Prevent empty todos
- Clear input after successful add
- Maintain focus appropriately
- Support both click and keyboard interactions

*** Visual Feedback
- Immediate visual response to user actions
- Loading states if operations are async
- Clear indication of active filters
- Smooth transitions/animations (if used)

** Testing Considerations

*** Unit Testing
- Business logic thoroughly tested
- Pure functions isolated and tested
- Edge cases covered
- Mock external dependencies

*** Integration Testing
- User flows work end-to-end
- Storage persistence verified
- Filter logic works correctly
- Bulk operations tested

*** Code Coverage
- Aim for >80% coverage of business logic
- Critical paths have 100% coverage
- UI components have basic tests

** Code Style and Maintainability

*** Consistency
- Consistent code formatting
- Consistent naming patterns
- Consistent error handling approach
- Consistent state update patterns

*** Documentation
- Clear README with setup instructions
- Inline comments for complex logic
- JSDoc or similar for public APIs
- Architecture decision records for key choices

*** Modern Best Practices
- ES6+ features used appropriately
- No deprecated APIs
- Security best practices (XSS prevention)
- Performance best practices

** Anti-Patterns to Avoid

*** Common Mistakes
- Global variables for state
- Tight coupling between layers
- Inline styles mixed with logic
- Manual DOM manipulation in MVC/MVVM apps
- Memory leaks from event listeners
- Mutation of props/shared state

*** Poor Practices
- todo.id = Math.random() (use proper ID generation)
- Direct array index as keys in lists
- Business logic in event handlers
- Deeply nested callbacks
- Synchronous operations that block UI

** Evaluation Criteria Summary

*** High-Quality Implementation
- Clean, readable, maintainable code
- Proper separation of concerns
- Robust error handling
- Good performance characteristics
- Accessible to all users
- Well-tested codebase
- Follows framework/library best practices

*** Red Flags
- Spaghetti code with unclear flow
- Mixed responsibilities in components
- Poor or no error handling
- Performance issues with few todos
- Accessibility barriers
- No tests or very low coverage
- Outdated patterns or deprecated APIs